package provider

import (
	"context"
	"log"
	"net/http"

	"github.com/auth0/go-auth0/management"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/auth0/terraform-provider-auth0/internal/value"
)

func newLogStream() *schema.Resource {
	return &schema.Resource{
		CreateContext: createLogStream,
		ReadContext:   readLogStream,
		UpdateContext: updateLogStream,
		DeleteContext: deleteLogStream,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
		Description: "With this resource, you can manage your Auth0 log streams.",
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Name of the log stream.",
			},
			"type": {
				Type:     schema.TypeString,
				Required: true,
				ValidateFunc: validation.StringInSlice([]string{
					"eventbridge",
					"eventgrid",
					"http",
					"datadog",
					"splunk",
					"sumo",
				}, true),
				ForceNew:    true,
				Description: "Type of the log stream, which indicates the sink provider.",
			},
			"status": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ValidateFunc: validation.StringInSlice([]string{
					"active",
					"paused",
					"suspended",
				}, false),
				Description: "The current status of the log stream. Options are \"active\", \"paused\", \"suspended\".",
			},
			"filters": {
				Type:     schema.TypeList,
				Optional: true,
				Description: "Only logs events matching these filters will be delivered by the stream." +
					" If omitted or empty, all events will be delivered.",
				Elem: &schema.Schema{
					Type: schema.TypeMap,
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
			},
			"sink": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Required:    true,
				Description: "The sink configuration for the log stream.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"aws_account_id": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							RequiredWith: []string{"sink.0.aws_region"},
							Description:  "The AWS Account ID.",
						},
						"aws_region": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							RequiredWith: []string{"sink.0.aws_account_id"},
							Description:  "The AWS Region, e.g. \"us-east-2\").",
						},
						"aws_partner_event_source": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							Description: "Name of the Partner Event Source to be used with AWS. " +
								"Generally generated by Auth0 and passed to AWS, so this should " +
								"be an output attribute.",
						},
						"azure_subscription_id": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							RequiredWith: []string{"sink.0.azure_resource_group", "sink.0.azure_region"},
							Description:  "The unique alphanumeric string that identifies your Azure subscription.",
						},
						"azure_resource_group": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							RequiredWith: []string{"sink.0.azure_subscription_id", "sink.0.azure_region"},
							Description: "The Azure EventGrid resource group which allows you to manage all " +
								"Azure assets within one subscription.",
						},
						"azure_region": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							RequiredWith: []string{"sink.0.azure_subscription_id", "sink.0.azure_resource_group"},
							Description:  "The Azure region code, e.g. \"ne\")",
						},
						"azure_partner_topic": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							Description: "Name of the Partner Topic to be used with Azure. " +
								"Generally should not be specified.",
						},
						"http_content_format": {
							Type:         schema.TypeString,
							Optional:     true,
							RequiredWith: []string{"sink.0.http_endpoint", "sink.0.http_authorization", "sink.0.http_content_type"},
							Description: "The format of data sent over HTTP. Options are " +
								"\"JSONLINES\", \"JSONARRAY\" or \"JSONOBJECT\"",
							ValidateFunc: validation.StringInSlice([]string{
								"JSONLINES",
								"JSONARRAY",
								"JSONOBJECT",
							}, false),
						},
						"http_content_type": {
							Type:     schema.TypeString,
							Optional: true,
							Description: "The \"Content-Type\" header to send over HTTP. " +
								"Common value is \"application/json\".",
							RequiredWith: []string{"sink.0.http_endpoint", "sink.0.http_authorization", "sink.0.http_content_format"},
						},
						"http_endpoint": {
							Type:         schema.TypeString,
							Optional:     true,
							Description:  "The HTTP endpoint to send streaming logs.",
							RequiredWith: []string{"sink.0.http_content_format", "sink.0.http_authorization", "sink.0.http_content_type"},
						},
						"http_authorization": {
							Type:         schema.TypeString,
							Optional:     true,
							Sensitive:    true,
							Description:  "Sent in the HTTP \"Authorization\" header with each request.",
							RequiredWith: []string{"sink.0.http_content_format", "sink.0.http_endpoint", "sink.0.http_content_type"},
						},
						"http_custom_headers": {
							Type: schema.TypeList,
							Elem: &schema.Schema{
								Type: schema.TypeMap,
								Elem: &schema.Schema{Type: schema.TypeString},
							},
							Optional:    true,
							Default:     nil,
							Description: "Additional HTTP headers to be included as part of the HTTP request.",
						},
						"datadog_region": {
							Type:         schema.TypeString,
							Optional:     true,
							RequiredWith: []string{"sink.0.datadog_api_key"},
							ValidateFunc: validation.StringInSlice(
								[]string{"us", "eu", "us3", "us5"},
								false,
							),
							Description: "The Datadog region. Options are [\"us\", \"eu\", \"us3\", \"us5\"].",
						},
						"datadog_api_key": {
							Type:         schema.TypeString,
							Optional:     true,
							Sensitive:    true,
							RequiredWith: []string{"sink.0.datadog_region"},
							Description:  "The Datadog API key.",
						},
						"splunk_domain": {
							Type:         schema.TypeString,
							Optional:     true,
							RequiredWith: []string{"sink.0.splunk_token", "sink.0.splunk_port", "sink.0.splunk_secure"},
							Description:  "The Splunk domain name.",
						},
						"splunk_token": {
							Type:         schema.TypeString,
							Optional:     true,
							Sensitive:    true,
							RequiredWith: []string{"sink.0.splunk_domain", "sink.0.splunk_port", "sink.0.splunk_secure"},
							Description:  "The Splunk access token.",
						},
						"splunk_port": {
							Type:         schema.TypeString,
							Optional:     true,
							RequiredWith: []string{"sink.0.splunk_domain", "sink.0.splunk_token", "sink.0.splunk_secure"},
							Description:  "The Splunk port.",
						},
						"splunk_secure": {
							Type:         schema.TypeBool,
							Optional:     true,
							Default:      nil,
							RequiredWith: []string{"sink.0.splunk_domain", "sink.0.splunk_port", "sink.0.splunk_token"},
							Description:  "This toggle should be turned off when using self-signed certificates.",
						},
						"sumo_source_address": {
							Type:     schema.TypeString,
							Optional: true,
							Default:  nil,
							Description: "Generated URL for your defined HTTP source in " +
								"Sumo Logic for collecting streaming data from Auth0.",
						},
					},
				},
			},
		},
	}
}

func createLogStream(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	api := m.(*management.Management)

	logStream := expandLogStream(d)
	if err := api.LogStream.Create(logStream); err != nil {
		return diag.FromErr(err)
	}

	d.SetId(logStream.GetID())

	// The Management API only allows updating a log stream's status. Therefore,
	// if the status field was present in the configuration, we perform an
	// additional operation to modify it.
	status := String(d, "status")
	if status != nil && *status != logStream.GetStatus() {
		if err := api.LogStream.Update(logStream.GetID(), &management.LogStream{Status: status}); err != nil {
			return diag.FromErr(err)
		}
	}

	return readLogStream(ctx, d, m)
}

func readLogStream(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	api := m.(*management.Management)

	logStream, err := api.LogStream.Read(d.Id())
	if err != nil {
		if mErr, ok := err.(management.Error); ok && mErr.Status() == http.StatusNotFound {
			d.SetId("")
			return nil
		}
		return diag.FromErr(err)
	}

	result := multierror.Append(
		d.Set("name", logStream.GetName()),
		d.Set("status", logStream.GetStatus()),
		d.Set("type", logStream.GetType()),
		d.Set("filters", logStream.Filters),
		d.Set("sink", flattenLogStreamSink(logStream.Sink)),
	)

	return diag.FromErr(result.ErrorOrNil())
}

func updateLogStream(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	api := m.(*management.Management)

	logStream := expandLogStream(d)
	if err := api.LogStream.Update(d.Id(), logStream); err != nil {
		return diag.FromErr(err)
	}

	return readLogStream(ctx, d, m)
}

func deleteLogStream(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	api := m.(*management.Management)

	if err := api.LogStream.Delete(d.Id()); err != nil {
		if mErr, ok := err.(management.Error); ok && mErr.Status() == http.StatusNotFound {
			d.SetId("")
			return nil
		}
	}

	d.SetId("")
	return nil
}

func flattenLogStreamSink(sink interface{}) []interface{} {
	var m interface{}

	switch sinkType := sink.(type) {
	case *management.LogStreamSinkAmazonEventBridge:
		m = flattenLogStreamSinkAmazonEventBridge(sinkType)
	case *management.LogStreamSinkAzureEventGrid:
		m = flattenLogStreamSinkAzureEventGrid(sinkType)
	case *management.LogStreamSinkHTTP:
		m = flattenLogStreamSinkHTTP(sinkType)
	case *management.LogStreamSinkDatadog:
		m = flattenLogStreamSinkDatadog(sinkType)
	case *management.LogStreamSinkSplunk:
		m = flattenLogStreamSinkSplunk(sinkType)
	case *management.LogStreamSinkSumo:
		m = flattenLogStreamSinkSumo(sinkType)
	}

	return []interface{}{m}
}

func flattenLogStreamSinkAmazonEventBridge(o *management.LogStreamSinkAmazonEventBridge) interface{} {
	return map[string]interface{}{
		"aws_account_id":           o.GetAccountID(),
		"aws_region":               o.GetRegion(),
		"aws_partner_event_source": o.GetPartnerEventSource(),
	}
}

func flattenLogStreamSinkAzureEventGrid(o *management.LogStreamSinkAzureEventGrid) interface{} {
	return map[string]interface{}{
		"azure_subscription_id": o.GetSubscriptionID(),
		"azure_resource_group":  o.GetResourceGroup(),
		"azure_region":          o.GetRegion(),
		"azure_partner_topic":   o.GetPartnerTopic(),
	}
}

func flattenLogStreamSinkHTTP(o *management.LogStreamSinkHTTP) interface{} {
	return map[string]interface{}{
		"http_endpoint":       o.GetEndpoint(),
		"http_content_format": o.GetContentFormat(),
		"http_content_type":   o.GetContentType(),
		"http_authorization":  o.GetAuthorization(),
		"http_custom_headers": o.CustomHeaders,
	}
}

func flattenLogStreamSinkDatadog(o *management.LogStreamSinkDatadog) interface{} {
	return map[string]interface{}{
		"datadog_region":  o.GetRegion(),
		"datadog_api_key": o.GetAPIKey(),
	}
}

func flattenLogStreamSinkSplunk(o *management.LogStreamSinkSplunk) interface{} {
	return map[string]interface{}{
		"splunk_domain": o.GetDomain(),
		"splunk_token":  o.GetToken(),
		"splunk_port":   o.GetPort(),
		"splunk_secure": o.GetSecure(),
	}
}

func flattenLogStreamSinkSumo(o *management.LogStreamSinkSumo) interface{} {
	return map[string]interface{}{
		"sumo_source_address": o.GetSourceAddress(),
	}
}

func expandLogStream(d *schema.ResourceData) *management.LogStream {
	config := d.GetRawConfig()

	logStreamType := value.String(config.GetAttr("type"))

	logStream := &management.LogStream{
		Name: value.String(config.GetAttr("name")),
	}

	if d.IsNewResource() {
		logStream.Type = logStreamType
	}

	if !d.IsNewResource() {
		logStream.Status = value.String(config.GetAttr("status"))
	}

	filtersConfig := config.GetAttr("filters")
	if !filtersConfig.IsNull() {
		var filters []map[string]string

		filtersConfig.ForEachElement(func(_ cty.Value, filter cty.Value) (stop bool) {
			filters = append(filters, *value.MapOfStrings(filter))
			return true
		})

		if len(filters) > 0 {
			logStream.Filters = &filters
		}
	}

	config.GetAttr("sink").ForEachElement(func(_ cty.Value, sink cty.Value) (stop bool) {
		switch *logStreamType {
		case management.LogStreamTypeAmazonEventBridge:
			// LogStreamTypeAmazonEventBridge cannot be updated.
			if d.IsNewResource() {
				logStream.Sink = expandLogStreamSinkAmazonEventBridge(sink)
			}
		case management.LogStreamTypeAzureEventGrid:
			// LogStreamTypeAzureEventGrid cannot be updated.
			if d.IsNewResource() {
				logStream.Sink = expandLogStreamSinkAzureEventGrid(sink)
			}
		case management.LogStreamTypeHTTP:
			logStream.Sink = expandLogStreamSinkHTTP(sink)
		case management.LogStreamTypeDatadog:
			logStream.Sink = expandLogStreamSinkDatadog(sink)
		case management.LogStreamTypeSplunk:
			logStream.Sink = expandLogStreamSinkSplunk(sink)
		case management.LogStreamTypeSumo:
			logStream.Sink = expandLogStreamSinkSumo(sink)
		default:
			log.Printf("[WARN]: Unsupported log stream sink %s", logStream.GetType())
			log.Printf("[WARN]: Raise an issue with the auth0 provider in order to support it:")
			log.Printf("[WARN]: 	https://github.com/auth0/terraform-provider-auth0/issues/new")
		}

		return stop
	})

	return logStream
}

func expandLogStreamSinkAmazonEventBridge(config cty.Value) *management.LogStreamSinkAmazonEventBridge {
	return &management.LogStreamSinkAmazonEventBridge{
		AccountID: value.String(config.GetAttr("aws_account_id")),
		Region:    value.String(config.GetAttr("aws_region")),
	}
}

func expandLogStreamSinkAzureEventGrid(config cty.Value) *management.LogStreamSinkAzureEventGrid {
	return &management.LogStreamSinkAzureEventGrid{
		SubscriptionID: value.String(config.GetAttr("azure_subscription_id")),
		ResourceGroup:  value.String(config.GetAttr("azure_resource_group")),
		Region:         value.String(config.GetAttr("azure_region")),
		PartnerTopic:   value.String(config.GetAttr("azure_partner_topic")),
	}
}

func expandLogStreamSinkHTTP(config cty.Value) *management.LogStreamSinkHTTP {
	httpSink := &management.LogStreamSinkHTTP{
		ContentFormat: value.String(config.GetAttr("http_content_format")),
		ContentType:   value.String(config.GetAttr("http_content_type")),
		Endpoint:      value.String(config.GetAttr("http_endpoint")),
		Authorization: value.String(config.GetAttr("http_authorization")),
	}

	customHeadersConfig := config.GetAttr("http_custom_headers")
	if !customHeadersConfig.IsNull() {
		customHeaders := make([]map[string]string, 0)

		customHeadersConfig.ForEachElement(func(_ cty.Value, httpHeader cty.Value) (stop bool) {
			customHeaders = append(customHeaders, *value.MapOfStrings(httpHeader))
			return stop
		})

		httpSink.CustomHeaders = &customHeaders
	}

	return httpSink
}
func expandLogStreamSinkDatadog(config cty.Value) *management.LogStreamSinkDatadog {
	return &management.LogStreamSinkDatadog{
		Region: value.String(config.GetAttr("datadog_region")),
		APIKey: value.String(config.GetAttr("datadog_api_key")),
	}
}
func expandLogStreamSinkSplunk(config cty.Value) *management.LogStreamSinkSplunk {
	return &management.LogStreamSinkSplunk{
		Domain: value.String(config.GetAttr("splunk_domain")),
		Token:  value.String(config.GetAttr("splunk_token")),
		Port:   value.String(config.GetAttr("splunk_port")),
		Secure: value.Bool(config.GetAttr("splunk_secure")),
	}
}
func expandLogStreamSinkSumo(config cty.Value) *management.LogStreamSinkSumo {
	return &management.LogStreamSinkSumo{
		SourceAddress: value.String(config.GetAttr("sumo_source_address")),
	}
}
